- [变量](#变量)
- [数据类型](#数据类型)
    - [Null](#null)
    - [Boolean](#boolean)
    - [Number](#number)


### 变量

- 未进过初始化的变量为`undefined`
-  `var`操作符定义的变量将成为定义该变量的作用域中的局部变量

```js
function test(){
    var message = "hi"; // 局部变量
}

//不建议
function test(){
    message = "hi"; // 全局变量 
}
```

<br/>

### 数据类型

`Undefined`, `Null`, `String`, `Number`, `Boolan`, `Object`

typeof用于检测给定变量的数据类型。

- "undefined"——如果这个值未定义;
- "boolean"——如果这个值是布尔值;
- "string"——如果这个值是字符串;
- "number"——如果这个值是数值;
- "object"——如果这个值是对象或 null;
- "function"——如果这个值是函数。

令人困惑的是:对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行typeof操作符同样也会返回undefined 值。

```js
var message; // 这个变量声明之后默认取得了 undefined 值 // 下面这个变量并没有声明
 // var age
alert(typeof message);
alert(typeof age);
// "undefined"
// "undefined"
```

<br/>

### Null

只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。


```js
undefined == null   //true
undefined === null  //false
```

<br/>

### Boolean
`true`和`false`, Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说，True 和 False (以及其他的混合大小写形式)都不是 Boolean 值，只是标识符。

要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()

| 数据类型     | 转换为true的值     | 转换为false的值     |
| --------   | :-----:   | :----: |
|Boolean|true|false|
|String|非空字符串|"“|
|Number|任何非零数字值|0和NaN|
|Object|任何对象|null|
|Undefined|不适用|undefined|

<br/>

### Number

```js
var octalNum1 = 070;  // 八进制的 56
var octalNum2 = 079;  // 无效的八进制数值——解析为 79
var octalNum3 = 08;   // 无效的八进制数值——解析为 8
```
八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。

```js
var hexNum1 = 0xA; // 十六进制的 10
var hexNum2 = 0x1f; // 十六进制的 31
```

#### 浮点数值
保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。
```js
var floatNum1 = 1.; // 小数点后面没有数字——解析为1
var floatNum2 = 10.0; // 整数——解析为 10
```

```js
var floatNum = 3.125e7; // 等于31250000
```

注意： 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。

#### NaN
NaN，即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。

比如： 任何数值除以0会返回NaN。

- 任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN。
- NaN 与任何值都不相等，包括 NaN 本身。

`ECMAScript`定义了`isNaN()`函数。这个函数接受一个参数，该参数可以 是任何类型，而函数会帮我们确定这个参数是否“不是数值”。`isNaN()`在接收到一个值之后，会尝试 将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10"或 `Boolean`值。而任何 不能被转换为数值的值都会导致这个函数返回`true`。

```js 
alert(isNaN(NaN));      //true
alert(isNaN(10));       //false(10 是一个数值
alert(isNaN("10"));     //false(可以被转换成数值 10)
alert(isNaN("blue"));   //true(不能转换成数值)
alert(isNaN(true));     //false(可以被转换成数值 1)
```

> <font size='2'>尽管有点儿不可思议，但`isNaN()`确实也适用于对象。在基于对象调用`isNaN()`函数时，会首先调用对象的`valueOf()`方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用`toString()`方法，再测试返回值。而这个过程也是`ECMAScript`中内置函数和操作符的一般执行流程。</font>

#### 数值转换
有3个函数可以把非数值转换为数值: `Number()`、`parseInt()`和 `parseFloat()`。

##### Number

Number()函数的转换规则如下]。

- <font size='2'>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</font>
-  <font size='2'>如果是数字值，只是简单的传入和返回。</font>
- <font size='2'>如果是 null 值，返回 0。</font>
- <font size='2'>如果是 undefined，返回 NaN。</font>
- <font size='2'>如果是字符串，遵循下列规则:</font>
    - <font size='2'>如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即"1" 会变成1，"123"会变成123，而"011"会变成11(注意:前导的零被忽略了);</font>
    - <font size='2'>如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值(同样，也会忽 略前导零);</font>
    - <font size='2'>如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整 数值;</font>
    - <font size='2'>如果字符串是空的(不包含任何字符)，则将其转换为 0;</font>
    - <font size='2'>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</font>
- <font size='2'>如果是对象，则调用对象的valueOf()方法，然后依照前面的则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。</font>

##### parseInt

由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt()函数。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN; 直到解析完所有后续字符或者遇到了一个非数字字符。**用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。**

```js
var num1 = parseInt("1234blue");    //1234
var num2 = parseInt("");            //NaN
var num3 = parseInt("0xA");        //10(十六进制数) 
var num4 = parseInt(22.5);          //22
var num5 = parseInt("070");         //56(八进制数)
var num6 = parseInt("70");          //70
var num7 = parseInt("0xf");         //15(十六进制数)
```

> 在使用 parseInt()解析像八进制字面量的字符串时，ECMAScript 3 和 5 存在分歧。

为了消除在使用 parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数:转换 时使用的基数(即多少进制)。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第 二个参数，可以保证得到正确的结果。

```js
var num1 = parseInt("0xAF", 16); //175   果指定了 16 作为第二个参数，字符串可以不带前面的"0x"

var num1 = parseInt("10", 2);   //2 (按二进制解析)
```
##### parseFloat

parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说， "22.34.5"将会被转换为 22.34。

parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。 所以parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。

最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点，或者小数点后 都是零)，parseFloat()会返回整数。

```js
var num1 = parseFloat("1234blue");      //1234
var num2 = parseFloat("0xA");           //0
var num3 = parseFloat("22.5");          //22.5
var num4 = parseFloat("22.34.5");       //22.34
var num5 = parseFloat("0908.5");        //908.5
var num6 = parseFloat("3.125e7");       //31250000
var num6 = parseFloat("3");             //3     不是3.0哦， 
```