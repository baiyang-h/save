### 函数参数的默认值

```js
function log(x, y = 'World') {
  console.log(x, y);
}
//参数变量是默认声明的，所以不能用let或const再次声明。
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```

#### 与解构赋值默认值结合使用

```javascript
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
//因为{x, y=5}没有设置默认值
foo() // TypeError: Cannot read property 'x' of undefined
```

改为

```javascript
function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
```

注意：

```js
function fn(a, {aa=1, bb=2}) {
    console.log(aa)
}
fn(1)  //报错

//如果第二个参数是一个对象，并且对他的属性设置了默认值，那么必须传入第二个参数或者设置该对象的解构
function fn(a, {aa=1, bb=2}={}) {	//这样就不会报错了
    console.log(aa)
}
```

作为练习，请问下面两种写法有什么差别？

```javascript
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
```

写法一函数参数的默认值是空对象，并且设置了对象解构的默认值。

写法二函数参数的默认值是一个具有属性的对象，但是没有设置对象解构赋值的默认值，

所以只要调用函数没有传入参数就引用对象的默认值，传入了参数就进行x、y和传入参数对象的解构。

```javascript
// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```

#### 参数默认值的位置

如果传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果。

```javascript
function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
```

