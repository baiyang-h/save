- [节点层次](节点层次)
  - [节点关系](#节点关系)
  - [操作节点](#操作节点)
  - [Document类型](#Document类型)
    - [文档的子节点](#文档的子节点)
    - [文档信息](#文档信息)
    - [查找元素](#查找元素)
    - [文档写入](#文档写入)
  - [Element类型](#Element类型)
    - [HTML类型](#HTML类型)
    - [操作特性](#操作特性)
    - [创建元素](#创建元素)
- [DOM操作技术](#DOM操作技术)
  - [动态脚本](#动态脚本)
  - [动态样式](#动态样式)



## DOM

### 节点层次

#### 节点关系

`节点.nodeName`为标签名字。

1. 每个节点都有一个`childNodes`属性，其中保存着一个`NodeList`对象，`NodeList`是一种类数组对象，用于保存一组有序的节点，可以使用方括号语法来访问`NodeList`，而且这个对象也有`length`属性，但它并不是`Array`实例。其中`childNodes`对象的集合是**包括节点内部的空白节点等所有节点**。

```html
<div id="root">
    <p>111</p> 
	<div>222</div>
</div>
<script>
    let r = document.getElementById('root');
	console.log(r.childNodes)  //NodeList(5) [text, p, text, div, text]
</script>
```

```js
var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);  //类数组转数组
```

2. `节点.children`不包括换行空白等文本节点。
3. 每个节点都有一个`parentNode`属性，该属性指向文档树中的父节点。
4. 每个节点的`previousSibling`和`nextSibling`属性，表示前一个节点和后一个节点， 包括空白节点、文本节点等。
5. 父节点的`firstChild`和`lastChild`属性，分别指向其`childNodes`列表中的第一个和最后一个节点。即包括空白文本节点。
6. `节点.hasChildNodes()`, 这个方法在节点包含一或多个子节点的情况下返回`true`，包括文本节点。

![节点之间的关系图](./images/2018-10-14_160431.png)

#### 操作节点

```js
//如果newNode已经是文档的一部分了，那么就是将该节点从原来的位置转移到新位置
var addNode = 某个节点中.appendChild(newNode)  

//insertNode为插入的节点， 和上面一下，如果是文档中的一部分，则转移
var insertNode = 某个节点中.insertBefore(要插入的节点， 作为参照的节点);

//替换节点, replaceNode为被替换的节点
var replaceNode = 某个节点中.replaceChild(要插入的节点， 要替换的节点);

//移除节点
var removeNode = 某个节点中.removeChild(要移除的节点);

//克隆节点，参数为true则深克隆(整个节点树)，false则只克隆节点本身。这个方法不会复制添加到DOM节点中的JavaScript属性，比如事件等， 只复制特性、子节点
节点.cloneNode(true | false)

```

#### Document类型

##### 文档的子节点

```js
var html = document.documentElement;	//取得<html>的引用
alert(html === document.childNodes[0]);	//true
alert(html === document.firstChild);	//true

var body = document.body;		//取得对<body>的引用
```

##### 文档信息

```js
document.title;				//取得文档标题
document.title = '设置文档标题';
//所有这些信息都存在于请求的HTTP头部
var url = document.URL;		//取得完整的URL
var domain = document.domain;	//取得域名
var referrer = document.referrer;	//取得来源页面的URL
```

上面的文档信息中只有`document.title`和`document.domain`可以被设置。由于安全方面的限制，也并非可以给`domain`设置任何值，如果URL中包含一个子域名，例如`p2p.wrox.com`，那么就只能将domain设置为`wrox.com`，因为`p2p.wrox.com`是`wrox.com`的子域，现在设置的`wrox.com`为主域。

```js
//假设页面来自 p2p.wrox.com 域
document.domain = "wrox.com"; // 成功
document.domain = "nczonline.net"; // 出错！
```

当页面中包含来自其他子域的框架或内嵌框架时，因为域名不同时存在跨域问题，来自不同子域的页面无法通过JavaScript通信。而通过将每个页面的`document.domain`设置为相同的域，这些页面就可以互相访问对方的JavaScript对象了。

例如：假设有一个页面加载自 `www.wrox.com`，其中包含一个内嵌框架，框架内的页面加载自 `p2p.wrox.com`。
由于 `document.domain` 字符串不一样，内外两个页面之间无法相互访问对方的 JavaScript 对象。但如
果将这两个页面的 `document.domain` 值都设置为`wrox.com`，它们之间就可以通信了。 （可以查看跨域通信那节）。

当对document.domain设置过之后，就不能再将其设置回去了。

##### 查找元素

```js
document.getElementById();	
document.getElementsByTagName();
document.getElementsByTagName('*');
document.querySelector(css选择器);		//只取第一个  静态的
document.querySelectorAll(css选择器);	//类数组 	静态的

//对于有name属性的元素
元素.nameItem(name名);
元素[name名];

document.getElementsByName()	//返回带有给定name特性的所有元素

//一些特殊集合
document.anchors;	//包含文档中所有带 name 特性的<a>元素；
document.forms;		//包含文档中所有的<form>元素，与document.getElementsByTagName("form")得到的结果相同；
document.images;	//包含文档中所有的<img>元素，与 document.getElementsByTagName("img")得到的结果相同；
document.links;		//包含文档中所有带 href 特性的<a>元素。
```

表单中的`name`和`id`在ie7中存在一个bug，不能同名。

##### 文档写入

```js
document.write()
document.writeln()		//会在字符串末尾加上一个换行符(\n)
```

注意

```html
<body>
	<div id="one">111</div> 
<script>
    //如果直接这么写则是页面在呈现的过程中输出了内容，所以不会被覆盖。<div>111</div>也有
    document.write('aaaaaaaaa');
    
    /*
    这种情况就是页面都加载完的情况下写入，会覆盖掉
    window.onload = function() {
        document.write('Hello world!')
    }
    */
</script>
</body>
```

#### Element类型

在html中和xml中使用e.target.tagName的输出是不一样的，所以最好是

```js
if(element.tagName == 'div') {   //这样容易出错，不建议
    //do
}
if(element.tagName.toLowerCase()  == 'div') {  //这样最好，适合任何文档
    //do
}
```

##### HTML元素

HTMLElement 类型直接继承自 Element 并添加了一些属性。添加的这些属性分别对应于每个 HTML
元素中都存在的下列标准特性。

- `id`
- `title`
- `lang`，使用的较少
- `dir`，语言的方向，值为`ltr`或`rtl`，也很少使用
- `className`，因为class是ECMAScript的保留字，所以没用class命名

```js
<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"></div>
```

##### 操作特性

操作特性的DOM方法主要有三个，分别是`getAttribute()`、`setAttribute()`和`removeAttribute()`。

```js
//getAttribute()

element.getAttribute('id');		//一般用于自定义属性
//或
element[属性名]			//HTMLElement公认的属性可以直接使用这种方式获取  element.align
element.属性名
```

其中对于`style`属性使用`element.style`获取到的是一个对象，而通过`getAttribute()`得到的则是一个文本。

对于`onclick`等事件得到的则是一个函数，如果没有则返回null。

我们一般经常不使用`getAttribute()`，而是只使用对象的属性。只有在取得自定义属性的情况下，才会使用`getAttribute()`方法。

```js
//setAttribute()

element.setAttribute('id', 'someOtherId');
//或 对于默认允许的所有属性 可以直接设置
element.id = 'someOtherId';
div.align = 'left';

//不过随便添加一个自定义属性，则不会成为元素的特性
div.mycolor = 'red';
alert(div.getAttribute('mycolor'));		//null(ie除外)
```

```js
//removeAttribute()

element.removeAttribute('class'); 
```

##### 创建元素

```js
var div = document.createElement('div');

div.className = 'a';
div.innerHTML = '<p>hello</p>';
```



### DOM操作技术

##### 动态脚本

跟操作HTML元素一样，创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript代码。

动态加载外部JavaScript文件能够立即运行，如：

```js
//第一种
<script type="text/javascript" src="client.js"></script>

var script = document.createElement('script');
script.type = 'text/javascript';
script.src = 'client.js';
document.body.appendChild(script);
```

```js
//第二种
<script type="text/javascript">
    function sayHi() {
    	alert('hi');
	}
</script>

var script = document.createElement('script');
script.type = 'text/javascript';
script.appendChild(document.createTextNode("function sayHi(){alert('hi')}"));
document.body.appendChild(script);
```

但是这里ie和老的safari存在兼容问题，所以使用以下方式处理兼容问题

```js
var script = document.createElement('script');
script.type = 'text/javascript';
var code = 'xxx';
try {
    script.appendChild(document.createTextNode(code));
} catch(ex) {
    script.text = code;
}
document.body.appendChild(script);
```

##### 动态样式

和上面的动态脚本一样

```js
//第一种
<link rel="stylesheet" type="text/css" href="style.css">
```

```js
//第二种
<style type="text/css">
    body {
        background-color: red;
    }
</style>

var style = document.createElement("style");
style.type = "text/css"; 
style.appendChild(document.createTextNode("body{background-color:red}")); 
var head = document.getElementsByTagName("head")[0]; 
head.appendChild(style);
```

```js
//兼容写法
var style = document.createElement("style"); style.type = "text/css";
try{
	style.appendChild(document.createTextNode("body{background-color:red}"));
} catch (ex){
    style.styleSheet.cssText = "body{background-color:red}";
}
var head = document.getElementsByTagName("head")[0];
head.appendChild(style);
```
