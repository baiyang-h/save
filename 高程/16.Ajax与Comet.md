### XMLHttpRequest对象

```js
var xhr = new XMLHttpRequest();
```

#### XHR的用法

在使用XHR对象时，要调用的第一个方法是`open()`。接收3个参数：要发送的请求类型(get、post)等、请求的URL和表示是否异步发送请求的布尔值(true为异步，fasle为同步)。

```js
xhr.open('get', 'xxx.php', false);
```

调用 `open()`方法并不会真正发送请求，而只是启动一个请求以备发送。

要发送特定的请求，必须调用 `send()`方法，可以在`send()`方法中传递参数。

```js
xhr.open("get", "example.txt", false);  //同步
xhr.send(null);
```

`send()`方法接收一个参数，**即要作为请求主体发送的数据(即请求体中传参数，一般用于post请求，get请求一般是请求头传参数)**。如果不需要通过请求主体发送数据，则必须传入 `null`,因为这个参数对有些浏览器来说是必需的。调用 `send()`之后，请求就会被分派到服务器。

在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下：

- `responseText`：作为响应主体被返回的文本。
- `responseXML`：如果响应的内容类型是`text/xml`或`application/xml`，这个属性中将保存包含着响应数据的 XML DOM 文档。 
- `status`:响应的 HTTP 状态。
- `statusText`:HTTP 状态的说明。

在接收到响应后，第一步是检查 `status` 属性，以确定响应已经成功返回。一般来说，可以将 HTTP状态代码为 `200` 作为成功的标志。此外，状态代码为 `304` 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本;当然，也意味着响应是有效的。

```js
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
      alert(xhr.responseText);
  } else {
      alert("Request was unsuccessful: " + xhr.status);
}
```

当我们发送的是异步请求的时候，此时我们可以检测XHR对象的`readyState`属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下：

- 0：未初始化。尚未调用`open()`方法。
- 1：启动。已经调用`open()`方法，但尚未调用`send()`方法。
- 2：发送。已经调用`send()`方法，但尚未接收到响应。
- 3：接收。已经接收到部分响应数据。
- 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。

只要 `readyState` 属性的值由一个值变成另一个值，都会触发一次 `readystatechange` 事件。可以利用这个事件来检测每次状态变化后 `readyState` 的值。通常，我们只对 `readyState` 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用 `open()`之前指定 `onreadystatechange`事件处理程序才能确保跨浏览器兼性。

```js
var xhr = createXHR();
    xhr.onreadystatechange = function(){
        if (xhr.readyState == 4){
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
                  alert(xhr.responseText);
        } else {
             alert("Request was unsuccessful: " + xhr.status);
        }
} };
xhr.open("get", "example.txt", true);
xhr.send(null);
```

> 这个例子在 onreadystatechange 事件处理程序中使用了 xhr 对象，没有使用this 对象，原因是onreadystatechange 事件处理程序的作用域问题。如果使用this 对象，在有的浏览器中会导致函数执行失败，或者导致错误发生。因此，使用实际的 XHR 对象实例变量是较为可靠的一种方式。

另外，在接收到响应之前还可以调用 abort()方法来取消异步请求，如下所示:

```js
xhr.abort();
```

调用这个方法后，XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。

#### HTTP头部信息

XHR 对象也提供了操作请求头部和响应头部信息的方法。

默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。

- Accept:浏览器能够处理的内容类型。 
- Accept-Charset:浏览器能够显示的字符集。 
- Accept-Encoding:浏览器能够处理的压缩编码。 
- Accept-Language:浏览器当前设置的语言。 
- Connection:浏览器与服务器之间连接的类型。 
- Cookie:当前页面设置的任何 Cookie。 
- Host:发出请求的页面所在的域 。 
- Referer:发出请求的页面的 URI。 
- User-Agent:浏览器的用户代理字符串。 

虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。

**使用 `setRequestHeader()`方法可以设置自定义的请求头部信息。**这个方法接受两个参数:头部字段的名称和头部字段的值。这个方法必须在`xhr.open()`方法之后，`xhr.send()`方法之前。

```js
xhr.open("get", "example.php", true); 
xhr.setRequestHeader("MyHeader", "MyValue"); 
xhr.send(null);
```

服务器在接收到这种自定义的头部信息之后，可以执行相应的后续操作。我们建议读者使用自定义的头部字段名称，不要使用浏览器正常发送的字段名称，否则有可能会影响服务器的响应。有的浏览器允许开发人员重写默认的头部信息，但有的浏览器则不允许这样做。

**调用 XHR 对象的 `getResponseHeader()`方法并传入头部字段名称，可以取得相应的响应头部信息。而调用 `getAllResponseHeaders()`方法则可以取得一个包含所有头部信息的长字符串。**

```js
var myHeader = xhr.getResponseHeader("MyHeader");
var allHeaders = xhr.getAllResponseHeaders();
```

#### GET请求

GET请求类型一般可以将查询字符串参数追加到URL末尾，以便将信息发送给服务器。并且最好我们还要将查询字符串经过正确的编码。**请求参数是在请求头中。**

查询字符串中每个参数的名称和值都必须使用 `encodeURIComponent()`进行编码，然后才能放到 URL 的末尾;而且所有`名-值`对儿都必须由`和号(&)`分隔。

```js
xhr.open("get", "example.php?name1=value1&name2=value2", true);
//可以进行编码
encodeURIComponent(name)和encodeURIComponent(value);
```

#### POST请求

**POST请求的参数是被放在请求体中**。POST请求可以发送非常多的数据，并且格式不限。

发送 `POST` 请求的第二步就是向 `send()`方法中传入某些数据。这些数据将被放在请求体中发送。

如果要通过XHR来模仿表单的提交：首先将 `Content-Type` 头部信息设置为 `application/x-www-form-urlencoded`，也就是表单提交时的内容类型，其次是以适当的格式创建一个字符串。

```js
xhr.open("post", "postexample.php", true); 
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
var form = document.getElementById("user-info");
xhr.send(new FormData(form));  //或  xhr.send('a=1&b=2&c=3')    表单的提交方式
```

- GET请求速度会比POST请求快，所以效率更高，消耗的资源更少。

- POST请求的参数在请求体中不能被看到，GET请求的参数在URL上可以被看到，相对来说POST请求更安全。

- POST请求可以传送的数据更多，并且数据类型不限。GET可以发送的数据大小少。

- POST是一个持续的连接，在服务端需要一个持续的事件监听，每次拿到数据进行积累。而GET请求则是一次性的请求。



### XMLHttpRequest2级

#### FormData

现代 Web 应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了`FormData` 类型。

`FormData`对象用以将数据编译成键值对，以便用`XMLHttpRequest`来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。如果表单`enctype`属性设为`multipart/form-data` ，则会使用表单的[`submit()`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLFormElement/submit)方法来发送数据，从而，发送数据具有同样形式。

```js
//键和值，分别对应表单字段的名字和字段中包含的值。
var data = new FormData();
data.append("name", "Nicholas");

//向 FormData 构造函数中直接传入表单元素
var data = new FormData(document.forms[0]);
```

创建了 `FormData` 的实例后，可以将它直接传给 XHR 的 `send()`方法。

```js
xhr.send(new FormData(form));
```

使用 `FormData` 的方便之处体现在不必明确地在 XHR 对象上设置请求头部。**XHR 对象能够识别传入的数据类型是 `FormData` 的实例，并配置适当的头部信息。**

支持 FormData 的浏览器有>=IE10、 Firefox 4+、Safari 5+、Chrome 和 Android 3+版 WebKit。

#### 超时设定

```js
//设置一个超时时间，表示请求在等待响应多少毫秒之后就终止。
xhr.timeout = 1000;
```

在给`timeout` 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 `timeout` 事
件，进而会调用 `ontimeout` 事件处理程序。

```js
xhr.open("get", "timeout.php", true);
xhr.timeout = 1000; 	
xhr.ontimeout = function(){
    alert("Request did not return in a second.");
};
xhr.send(null);
```

`timeout`超时事件兼容IE10，其他支持。

#### overrideMimeType()方法

`overrideMimeType()`方法，用于重写 XHR 响应的 `MIME` 类型。因为返回响应的 `MIME` 类型决定了 XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的 `MIME` 类型是很有用的。

比如，服务器返回的 `MIME` 类型是 `text/plain`，但数据中实际包含的是 `XML`。根据 `MIME` 类型，即使数据是`XML`，`responseXML` 属性中仍然是 `null`。通过调用 `overrideMimeType()`方法，可以保证把响应当作 `XML` 而非纯文本来处理。

```js
var xhr = createXHR(); 
xhr.open("get", "text.php", true); 
xhr.overrideMimeType("text/xml");
xhr.send(null);
```

这个例子强迫 XHR 对象将响应当作 `XML` 而非纯文本来处理。

调用 `overrideMimeType()`必须在`send()`方法之前，才能保证重写响应的 `MIME` 类型。

> 兼容：IE11、其他浏览器支持。



### 进度事件

- `loadstart`:在接收到响应数据的第一个字节时触发。
- `progress`:在接收响应期间持续不断地触发。
- `error`:在请求发生错误时触发。
- `abort`:在因为调用 `abort()`方法而终止连接时触发。
- `load`:在接收到完整的响应数据时触发。
- `loadend`:在通信完成或者触发 `error`、`abort` 或 `load` 事件后触发。

每个请求都从触发 `loadstart` 事件开始，接下来是一或多个 `progress` 事件，然后触发 `error`、 `abort` 或 `load` 事件中的一个，最后以触发 `loadend` 事件结束。

IE 8+只支持 load 事件。目前还没有浏览器支持 loadend 事件。 

#### load事件

