### XMLHttpRequest对象

```js
var xhr = new XMLHttpRequest();
```

#### XHR的用法

在使用XHR对象时，要调用的第一个方法是`open()`。接收3个参数：要发送的请求类型(get、post)等、请求的URL和表示是否异步发送请求的布尔值(true为异步，fasle为同步)。

```js
xhr.open('get', 'xxx.php', false);
```

调用 `open()`方法并不会真正发送请求，而只是启动一个请求以备发送。

要发送特定的请求，必须调用 `send()`方法，可以在`send()`方法中传递参数。

```js
xhr.open("get", "example.txt", false);  //同步
xhr.send(null);
```

`send()`方法接收一个参数，**即要作为请求主体发送的数据(即请求体中传参数，一般用于post请求，get请求一般是请求头传参数)**。如果不需要通过请求主体发送数据，则必须传入 `null`,因为这个参数对有些浏览器来说是必需的。调用 `send()`之后，请求就会被分派到服务器。

在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下：

- `responseText`：作为响应主体被返回的文本。
- `responseXML`：如果响应的内容类型是`text/xml`或`application/xml`，这个属性中将保存包含着响应数据的 XML DOM 文档。 
- `status`:响应的 HTTP 状态。
- `statusText`:HTTP 状态的说明。

在接收到响应后，第一步是检查 `status` 属性，以确定响应已经成功返回。一般来说，可以将 HTTP状态代码为 `200` 作为成功的标志。此外，状态代码为 `304` 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本;当然，也意味着响应是有效的。

```js
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
      alert(xhr.responseText);
  } else {
      alert("Request was unsuccessful: " + xhr.status);
}
```

当我们发送的是异步请求的时候，此时我们可以检测XHR对象的`readyState`属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下：

- 0：未初始化。尚未调用`open()`方法。
- 1：启动。已经调用`open()`方法，但尚未调用`send()`方法。
- 2：发送。已经调用`send()`方法，但尚未接收到响应。
- 3：接收。已经接收到部分响应数据。
- 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。

只要 `readyState` 属性的值由一个值变成另一个值，都会触发一次 `readystatechange` 事件。可以利用这个事件来检测每次状态变化后 `readyState` 的值。通常，我们只对 `readyState` 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用 `open()`之前指定 `onreadystatechange`事件处理程序才能确保跨浏览器兼性。

```js
var xhr = createXHR();
    xhr.onreadystatechange = function(){
        if (xhr.readyState == 4){
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
                  alert(xhr.responseText);
        } else {
             alert("Request was unsuccessful: " + xhr.status);
        }
} };
xhr.open("get", "example.txt", true);
xhr.send(null);
```

> 这个例子在 onreadystatechange 事件处理程序中使用了 xhr 对象，没有使用this 对象，原因是onreadystatechange 事件处理程序的作用域问题。如果使用this 对象，在有的浏览器中会导致函数执行失败，或者导致错误发生。因此，使用实际的 XHR 对象实例变量是较为可靠的一种方式。

另外，在接收到响应之前还可以调用 abort()方法来取消异步请求，如下所示:

```js
xhr.abort();
```

调用这个方法后，XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。

#### HTTP头部信息

XHR 对象也提供了操作请求头部和响应头部信息的方法。

默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。

- Accept:浏览器能够处理的内容类型。 
- Accept-Charset:浏览器能够显示的字符集。 
- Accept-Encoding:浏览器能够处理的压缩编码。 
- Accept-Language:浏览器当前设置的语言。 
- Connection:浏览器与服务器之间连接的类型。 
- Cookie:当前页面设置的任何 Cookie。 
- Host:发出请求的页面所在的域 。 
- Referer:发出请求的页面的 URI。 
- User-Agent:浏览器的用户代理字符串。 

虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。

**使用 `setRequestHeader()`方法可以设置自定义的请求头部信息。**这个方法接受两个参数:头部字段的名称和头部字段的值。这个方法必须在`xhr.open()`方法之后，`xhr.send()`方法之前。

```js
xhr.open("get", "example.php", true); 
xhr.setRequestHeader("MyHeader", "MyValue"); 
xhr.send(null);
```

服务器在接收到这种自定义的头部信息之后，可以执行相应的后续操作。我们建议读者使用自定义的头部字段名称，不要使用浏览器正常发送的字段名称，否则有可能会影响服务器的响应。有的浏览器允许开发人员重写默认的头部信息，但有的浏览器则不允许这样做。

**调用 XHR 对象的 `getResponseHeader()`方法并传入头部字段名称，可以取得相应的响应头部信息。而调用 `getAllResponseHeaders()`方法则可以取得一个包含所有头部信息的长字符串。**

```js
var myHeader = xhr.getResponseHeader("MyHeader");
var allHeaders = xhr.getAllResponseHeaders();
```

#### GET请求

GET请求类型一般可以将查询字符串参数追加到URL末尾，以便将信息发送给服务器。并且最好我们还要将查询字符串经过正确的编码。**请求参数是在请求头中。**

查询字符串中每个参数的名称和值都必须使用 `encodeURIComponent()`进行编码，然后才能放到 URL 的末尾;而且所有`名-值`对儿都必须由`和号(&)`分隔。

```js
xhr.open("get", "example.php?name1=value1&name2=value2", true);
//可以进行编码
encodeURIComponent(name)和encodeURIComponent(value);
```

#### POST请求

**POST请求的参数是被放在请求体中**。POST请求可以发送非常多的数据，并且格式不限。

发送 `POST` 请求的第二步就是向 `send()`方法中传入某些数据。这些数据将被放在请求体中发送。

如果要通过XHR来模仿表单的提交：首先将 `Content-Type` 头部信息设置为 `application/x-www-form-urlencoded`，也就是表单提交时的内容类型，其次是以适当的格式创建一个字符串。

```js
xhr.open("post", "postexample.php", true); 
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
var form = document.getElementById("user-info");
xhr.send(new FormData(form));  //或  xhr.send('a=1&b=2&c=3')    表单的提交方式
```

- GET请求速度会比POST请求快，所以效率更高，消耗的资源更少。

- POST请求的参数在请求体中不能被看到，GET请求的参数在URL上可以被看到，相对来说POST请求更安全。

- POST请求可以传送的数据更多，并且数据类型不限。GET可以发送的数据大小少。

- POST是一个持续的连接，在服务端需要一个持续的事件监听，每次拿到数据进行积累。而GET请求则是一次性的请求。

