- [Object类型](#object类型)
- [Array类型](#array类型)
    - [检测数组](#检测数组)
    - [转换方法](#转换方法)
    - [栈方法](#栈方法)
    - [队列方法](#队列方法)
    - [重排序方法](#重排序方法)
    - [操作方法](#操作方法)
    - [位置方法](#位置方法)
    - [迭代方法](#迭代方法)
    - [归并方法](#归并方法)
- [RegExp](#regexp)
    - [RegExp实例属性](#regexp实例属性)
    - [RegExp实例方法](#regexp实例方法)

对象是某个特定引用类型的实例。新对象是使用`new`操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。

```js
var person = new Object();
```

### Object类型
创建`Object`有两种方法：

1. 使用`new`操作符后跟Object构造函数。

```js
var person = new Object();
person.name = 'Nicholas';
person.age = 29;
```

2. 使用对象字面量表示法。

```js
var person = {
    name: 'Nicholas',
    age: 29
}
```

访问`Object`的两种方式:
1. `person.name`
2. `person['name']`

### Array类型
##### 创建`Array`有两种方法：
1. 第一种是使用`Array`构造函数。
```js
var colors = new Array();

var colors = new Array(20);  //创建length为20的数组， 但内部20个值其实都没有， 但取取值是undefined， 和[undefined···20个]是不一样的

var colors = new Array('red', 'orange', 'green');
```
2. 第二种使用数组字面量。
```js
var colors = ['red', 'orange', 'green'];
```

##### 访问和改写数组的值
索引从0开始

```js
array[index]    //访问
array[index] = xxx  //改写
```

##### length长度
```js
var colors = ['red', 'orange', 'green'];
colors.length   //3
```
数组的 length 属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。请看下面的例子:
```js
var colors = ['red', 'orange', 'green'];
colors.length = 2;      //['red', 'orange']
alert(colors[2])        //undefined

colors.length = 0;       //移除所有项  

colors.length = 7;      //新增的每一项都没定义defined(注意：不是没声明)，但去取得话是undefined
```

#### 检测数组
确认某个对象是不是数组的方法：
- 使用instanceof操作符
```js
if(value instanceof Array) {
    //xxx
}
```
- ECMAScript5新增了Array.isArray()方法
```js
if(Array.isArray(value)) {
    //xxx
}
```
#### 转换方法
- toLocaleString
- toString
- valueOf

首先，所有对象都具有toLocaleString()、toString()和valueOf()方法。

使用toString()会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而valueOf()返回的还是数组。

实际上对于为了创建这个字符串的数组， 数组内部的每个项都会去调用toString()这个方法。
```js
let colors = ['red', 'blue', 'green'];
alert(colors.toString());   //字符串    red,blue,green
alert(colors.valueOf());    //['red', 'blue', 'green']
```

```js
//join 将数组转为字符串
arr.join('-')
```

#### 栈方法
- push
- pop
```js
//改变原值
arr.push(value)
arr.pop(value)
```

#### 队列方法
- shift
- unshift
```js
//改变原值
arr.shift()
arr.push(value)
//还提供了unshift可以反向
arr.unshift()
arr.pop()
```

#### 重排序方法
- reverse
- sort
```js
//改变原值
arr.reverse()
arr.sort()  //默认从小到大

//也可以在sort中传入一个函数作为参数
arr.sort(function(a, b) {
    if(a < b) {
        return -1;      //返回负数从小到大
    }
    else if {
        return 1        //返回正数从大到小
    }
    else {
        return 0
    }
})
```

#### 操作方法
- concat: 如果传入的是字符串直接， 如果是数组则将内部的项添加。
```js
//创建的是一个副本， 不改变原来的值
['aa'].concat('a'， [1, 2])     //['aa', 'a', 1, 2]
```
- slice
```js
//副本
arr.slice(1)
arr.slice(1, 3)
arr.slice(-3, -1)
```
- splice
```js
arr.splice(索引, 删除的个数, 插入的值)
//例子
arr.splice(0, 2)        //删除数组前两项
arr.splice(2, 0, 'a')
arr.splice(2, 1, 'a', 'b')
```
#### 位置方法
```js
//没找到返回-1， 从第几项开始找， 找的值的位置是多少， 第一个参数可以选
arr.indexOf(索引, 值)
arr.lastIndexOf(索引, 值)
```

#### 迭代方法
可创建一个副本
- every
- some
- filter
- map
- forEach

#### 归并方法
- reduce
- reduceRight

方法存在两个参数，一个在每-项上调用的函数和(可选项)作为归并基础的初始值(即prev为这个值开始, cur就为数组的第一个值开始)。
而函数又接受4个参数： 前一个值、当前值、项的索引和数组对象， 这个函数返回的任何值都会作为第一个参数自动传给下一项。
```js
let values = [1, 2, 3, 4, 5];
let sum = values.reduce(function(prev, cur, index, array) {
    return prev + cur;
})
```

### RegExp
```js
let expression = /pattern/flags;
```
每个正则表达式都可带有一或多个标志(flags), 用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。查找到哪个位置，指针就在那个位置了。

- g: 表示全局模式, 即模式将被应用于所有字符串, 而非在发现第一个匹配项时立即停止,而是继续接下来的索引下去查找, 直到最后;
- i: 表示不区分大小写模式， 在匹配项时忽略字符串的大小写;
- m: 表示多行模式, 即在到达一行文本末尾时还会继续查找下一行中是否存在模式匹配项。

```js
//字面量形式来定义正则表达式
let pattern1 = /.[bc]at/gi
```
```js
//使用RegExp构造函数的方式
//接受两个参数，一个要匹配的字符串模式， 一个可选的标志字符串
let pattern2 = new RegExp('.[bc]at', 'gi')
```

在字符串中`\`通常转义为`\\`
|字面量模式|等价的字符串|
|:---:|:---:|
|`/\[bc\]at/`|`'\\[bc\\]at'`|
|`/\.at/|`|`'\\.at'`|

注意：
```js
var re = null, i;
for(i=0; i<10; i++) {
    re = /cat/g;            //同一个
    re.test('catastrophe');
}
for(i=0; i<10; i++) {
    re = new RegExp('cat', 'g');    //每次都是新的实例
    re.test('catastrophe');
}
```
上面两种情况是不一样的，第二种每次迭代都会创建一个新的RegExp实例。
ECMAScript5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。

#### RegExp实例属性
RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global:布尔值，表示是否设置了 g 标志。
- ignoreCase:布尔值，表示是否设置了 i 标志。
- lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
- multiline:布尔值，表示是否设置了 m 标志。
- source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

#### RegExp实例方法
- exec()

`exec()`方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或`null`。
```js
regexObj.exec(str)
```
如果匹配成功，`exec()`方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。如果匹配失败，`exec()`方法返回`null`。

例子：
```js
var re = /quick\s(brown).+?(jumps)/ig;
var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
```
<table>
    <thead>
        <th>对象</th>
        <th width=100>属性/索引</th>
        <th>描述</th>
        <th>例子</th>
    </thead>
    <tbody>
        <tr>
            <td>result</td>
            <td>[0]</td>
            <td>匹配的全部字符串</td>
            <td>Quick Brown Fox Jumps</td>
        </tr>
    </tbody>
</table>