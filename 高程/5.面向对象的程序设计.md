- [理解对象](#理解对象)
    - [属性类型](#属性类型)
    - [数据属性](#数据属性)


### 理解对象
创建对象
```js
var person = new Object();
person.name = 'zhangsan';
person.show = function() {

}
//或者
var person = {
    name: 'zhangsan',
    show() {
        //do
    }
}
```

#### 属性类型
每个属性都存在各种特性。这些特性能够影响属性的表示。

`ECMAScript` 中有两种属性：数据属性和访问器属性

##### 数据属性
```js
let o = {
    name: 'zhangsan',
    age: 24
}
```
数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。
- `configurable`: 表示能否通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true;
- `enumerable`: 表示能否通过 `for-in` 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`;
- `writable`: 表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。
- `value`: 包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 `undefined`。

对于像前面例子中那样直接在对象上定义的属性，它们的`[[Configurable]]`、 `[[Enumerable]]`和`[[Writable]]`特性都被设置为 `true`，而`[[Value]]`特性被设置为指定的值。

```js
var person = {
    name: 'Nicholas'
}
```
这里创建了一个名为 `name` 的属性，为它指定的值是`"Nicholas"`。也就是说， `[[Value]]`特性将被设置为`"Nicholas"`，而对这个值的任何修改都将反映在这个位置。

要修改属性默认的特性，必须使用 `ECMAScript 5` 的 `Object.defineProperty()`方法。这个方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象(即该对象的属性必须是: configurable、enumerable、writable、value中的一个或者多个)。

**注意：**
在调用`Object.defineProperty()`方法创建一个新的属性时,如果不指定`configurable`、`enumerable`和`writable`特性的默认值，那么就都是`false`, `value`为`undefined`。但是如果不是用在调用`Object.defineProperty()`创建新属性，属性一开始就被定义存在，那么就根据最开始的规则来，`configurable`、`enumerable`、`writable`默认为`true`,`value`为初始化的值，没有则为`undefined`。或者是很久前就被在调用`Object.defineProperty()`初始化过的特性。

记住当将`configurable`设置为false后，表示不能从对象中删除属性。而且一旦把属性定义为不可配置，就不能再把它变回可配置了。此时，再调用`Object.defineProperty()`方法修改`configurable`、`enumerable`会报错，而`writable`为`true`时修改成`false`不会报错，但是`false`改成`true`会报错,`value`则是根据`writable`来判定是否可写。

例子1
直接修改对象属性
```js
var person = {};
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas"
});
alert(person.name);     //"Nicholas"
person.name = "Greg";           //因为name属性的writable特性为不可写，所以不能被直接修改 报错
alert(person.name);     //"Nicholas"
```

例子2
```js
var person = {};
//一开始是空对象， 通过Object.defineProperty创建了一个新属性，所以configurable和enumerable默认为false
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas"
});
Object.defineProperty(person, "name", {
    writable: true,             //报错， 因为用Object.defineProperty新建的时候没有指定configurable，所以默认为false， 所以不能修改writable特性
    value: "adf"
});
```

例子3
通过`Object.defineProperty`来修改对象属性
```js
var person = {};
Object.defineProperty(person, "name", {
    configurable: true,
    writable: false,
    value: "Nicholas"
});
//person.name = 'abc';      写这句会报错， 因为writable为false
Object.defineProperty(person, "name", {
    //writable: true,
    value: "abc"        //但直接调用Object.defineProperty方法来修改value特性
});
console.log(person.name);       //bac
```
直接调用`Object.defineProperty`方法来修改`value`特性，即使`writable`是`false`，却还是能修改。为什么？ 因为其实当我们在调用该方法时，他内部默认是先将`writable`特性改为了`true`,等我们修改好后又将其特性改为`false`, 所以我们肉眼看到的是能通过该方法修改。

例子4
```js
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,            //不可配置
    writable: false,
    value: "Nicholas"
});

Object.defineProperty(person, "name", {
    value: "abc"            //报错
});
```
当我们在下面项修改value值时，`Object.defineProperty`方法会默认先去将`writable`特性改为`true`， 然后在变为`false`。但因为我们将`configurable`特性设置为了`false`,而当`configurable`为`false`的时候，`writable`特性是如果是`true`可以改为`false`, 但是从`false`改为`true`则会报错。

例子5
```js
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    writable: true,     
    value: "Nicholas"
});
Object.defineProperty(person, "name", {
    writable: false,        
    value: "abc"
});
console.log(person.name)        //abc
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
```
虽然`configurable`是`false`， 但是`writable`为`true`是可以被`Object.defineProperty`方法改为`false`的，但又因为调用`Object.defineProperty`修改`value`的时候，会默认现将`writable`先变为`true`，最后在改回到`false`，所以这里虽然看到`writable`为`false`但是`value`还是修改成功了。