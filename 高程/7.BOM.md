本章内容

- 理解window对象—BOM的核心
- 控制窗口、框架和弹出窗口
- 利用location对象中的页面信息
- 使用navigation对象了解浏览器



- [window对象](#window对象)

  - [全局作用域](#全局作用域)
  - [窗口关系及框架(frame)](#窗口关系及框架(frame))
  - [窗口位置](#窗口位置)
  - [窗口大小](#窗口大小)


### window对象

**BOM**的核心对象是`window`，它表示浏览器的一个实例。在浏览器中，`window`对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的`Global`对象。这意味在网页中定义的任何一个对象、变量和函数，都以`window`作为其`Global`对象，因此有权访问`parseInt()`等方法。

#### 全局作用域

1. 由于window对象同时扮演着ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。

>  注意：ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

```js
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

2. 抛开全局变量会成为`window`对象的属性不谈，定义全局变量与在`window`对象上直接定义属性还是有一点差别：全局变量不能通过`delete`删除，而直接在`window`对象上的定义的属性是可以的。

```js
var age = 29;
window.color = 'red';

//在IE<9时抛出错误，在其他所有浏览器中都返回false
delete window.age;

//在IE<9时抛出错误，在其他所有浏览器中都是返回true
delete window.color	//return true

alert(window.age);		//29
alert(window.color);	//undefined
```

刚才使用`var`语句添加`window`属性有一个名为`[[Configurable]]`的特性，这个特性的值被设置为`false`，因此这样定义的属性不可以通过`delete`删除。

> 注意：尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是都存在。

```js
//为什么的a，调用
a   //报错
window.a    //undefined

```

#### 窗口关系及框架(frame)

1. 如果页面中包含框架，则每个框架都拥有自己的`window`对象，并且保存在`frames`集合中。在`frames`集合中，可以通过数值索引(从0开始，从左到右，从上到右)或框架名称来访问相应的`window`对象。每个`window`对象都有一个`name`属性，其中包含框架的名称。

```html
<frame src="xx" name="abc">
```

2. `top`对象始终指向最高(最外)层的框架，也就是浏览器窗口。还有一个`parent`对象，`parent`(父)对象始终指向当前框架的直接上层框架。

```js
window.frames[0]	//建议使用top
top.frames[0]		//top永远是顶层    
parent.frames[0]	//当前frames的上层框架
```

3. 注意，除非最高层窗口是通过`window.open()`打开的，否则其`window`对象的`name`属性不会包含任何值。
4. 与框架有关的最后一个对象是`self`，它始终指向当前`window`

#### 窗口位置

1. IE、Safari、Opera和Chrome提供了`screenLeft`和`screenTop`属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则为`screenX`和`screenY`。

兼容写法：

```js
var leftPos = (typeof window.screenLeft == 'number') ? window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
```

2. 移动窗口

`moveTo()`接收的是新位置的 x 和 y 坐标值，而 `moveBy()`接收的是在水平和垂直方向上移动的像素数。

```js
//将窗口移动到屏幕左上角 
window.moveTo(0,0);
//将窗向下移动 100 像素 
window.moveBy(0,100);
//将窗口移动到(200,300) 
window.moveTo(200,300);
//将窗口向左移动 50 像素 
window.moveBy(-50,0);
```

#### 窗口大小

1. 在IE9+、Firefox、Safari、Opera和Chrome提供了4个属性：`innerWidth`、`innerHeight`、`outerWidth`和`outerHeight`。

   这里存在兼容性问题，在IE9+、Firefox、Safari中`outerWidth`和`outerHeight`返回浏览器窗口本身的尺寸。在Opera中这两个属性表示视图区。而`innerWidth`和`innerHeight`则表示页面视图区的大小。在Chrome中这四个属性返回相同的值，都是视口(viewport)大小而非浏览器窗口大小。

   在IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性，不过，它通过DOM提供了页面可见区域的相关信息。在 IE、Firefox、Safari、Opera 和 Chrome 中，`document.documentElement.clientWidth`和`document.documentElement.clientHeight`中保存了页面视口的信息。IE6中使用`document.body.clientWidth`。 

兼容写法：

```js
var pageWidth = window.innerWidth,
    pageHeight = window.innerHeight;
if (typeof pageWidth != "number"){
    if (document.compatMode == "CSS1Compat"){
        pageWidth = document.documentElement.clientWidth;
        pageHeight = document.documentElement.clientHeight;
    } else {
        pageWidth = document.body.clientWidth;
        pageHeight = document.body.clientHeight;
    }
}
```

2. 对于**移动设备**，`window.innerWidth` 和 `window.innerHeight` 保存着可见视口，也就是屏幕上可
   见页面区域的大小。移动 IE 浏览器不支持这些属性，但通过 `document.documentElement.client-`
   `Width` 和 `document.documentElement.clientHeihgt` 提供了相同的信息。随着页面的缩放，这些值
   也会相应变化。
3. `resizeTo()`和 `resizeBy()`方法可以调整浏览器窗口的大小。这两个方法都接收两个
   参数，其中 `resizeTo()`接收浏览器窗口的新宽度和新高度，而 `resizeBy()`接收新窗口与原窗口的宽
   度和高度之差。

```js
//调整到 100×100 
window.resizeTo(100, 100);
//调整到 200×150 
window.resizeBy(100, 50);
//调整到 300×300 
window.resizeTo(300, 300);
```

需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用; 而且，在 Opera和 IE7(及更高版本)中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。









