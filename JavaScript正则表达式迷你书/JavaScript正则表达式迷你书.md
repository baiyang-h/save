### 第一章 正则表达式字符匹配攻略

**正则表达式是匹配模式，要么匹配字符，要么匹配位置**。

#### 1.1 两种模糊匹配

- 横向模糊匹配

其实现的方式是使用量词。譬如 `{m,n}`，表示连续出现最少 m 次，最多 n 次。比如正则 `/ab{2,5}c/`

- 纵向模糊匹配

其实现的方式是使用字符组。譬如 `[abc]`，

#### 1.2 字符组

例如 `[abc]`

- 范围表示法：`[1-6a-fG-M]`
- 排除字符组：`[^abc]`

- 常见的简写形式

| 字符组 | 具体含义                                                     |
| ------ | ------------------------------------------------------------ |
| `\d`   | `[0-9]`                                                      |
| `\D`   | `[^0-9]`                                                     |
| `\w`   | `[0-9a-zA-Z_]`                                               |
| `\W`   | `[^0-9a-zA-Z_]`                                              |
| `\s`   | `[ \t\v\n\r\f]`。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 |
| `\S`   | `[^\t\v\n\r\f]`                                              |
| `.`    | `[^\n\r\u2028\u2029]`。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。 |

如果要匹配任意字符怎么办?可以使用 `[\d\D]`、`[\w\W]`、`[\s\S]` 和` [^] `中任何的一个。

#### 1.3 量词

| 量词   | 具体含义          |
| ------ | ----------------- |
| `{m,}` | 表示至少出现 m 次 |
| `{m}`  | 出现 m 次         |
| `?`    | {0,1}             |
| `+`    | {1,}              |
| `*`    | {0,}              |

##### 贪婪匹配与惰性匹配

正则它会尽可能多的匹配，是贪婪的。`/\d{2,5}/g`这里会尽量匹配多，如有5个会匹配5个。	

**通过在量词后面加个问号就能实现惰性匹配**。例如：`/\d{2,5}?/g`  这里只会匹配2个，尽可能少的匹配。

#### 1.4 多选分支

一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。

具体形式如下:`(p1|p2|p3)`，其中 p1、p2 和 p3 是子模式，用 `|(管道符)`分隔，表示其中任何之一。



例如要匹配字符串 "good" 和 "nice" 可以使用 /good|nice/。

```js
var regex = /goodbye|good/g;
var string = "goodbye";
console.log( string.match(regex) );
// => ["goodbye"]
```

分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了



### 第二章 正则表达式位置匹配攻略

#### 2.1 什么是位置呢？

位置(锚)是相邻字符之间的位置。比如，下图中箭头所指的地方:

![正则匹配时的位置](./images/1548471416766.jpg)

#### 2.2 如何匹配位置呢？

ES5中，共有6个锚：`^`、`$`、`\b`、`\B`、`(?=p)`、`(?!p)`。

注意：像上面的位置匹配符是匹配字符串中的位置，并不是字符串中的值。

```js
//匹配值
let str = 'abc';
str.repalce(/^a/g, '#');		//#bc
//匹配位置
str.repalce(/(?=b)/g, '#');		//a#bc
```



##### 2.2.1 ^和$

`^` ：匹配开头，在多行匹配中匹配行开头。

`$`：匹配结尾，在多行匹配中匹配行结尾。

```js
var result = "hello".replace(/^|$/g, '#');
console.log(result);
// => "#hello#"
```

多行匹配模式(即有修饰符`m`)时，二者是行的概念

```js
var result = "I\nlove\njavascript".replace(/^|$/gm, '#');
console.log(result);
/*
#I#
#love#
#javascript#
*/
```

##### 2.2.2 \b和\B

`\b`是单词边界，具体就是`\w`与`\W`之间的位置，也包括`\w`与`^`之间的位置，和`\w`与`$`之间的位置。

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```

##### 2.2.3 (?=p)和(?!p)

`(?=p)`，其中 p 是一个子模式，即 p 前面的**位置**，或者说，该**位置**后面的字符要匹配 p。

比如 (?=l)，表示 "l" 字符前面的位置，例如:

```js
var result = "hello".replace(/(?=l)/g, '#');
console.log(result);
// => "he#l#lo"
```

而 `(?!p)` 就是 `(?=p)` 的反面意思，就是不是p前面的位置，也可以说，该位置后面的字符不匹配p

```js
var result = "hello".replace(/(?!l)/g, '#');
console.log(result);
// => "#h#ell#o#"
```

#### 2.4 例子

数字的千位分隔符表示法，比如把 "12345678"，变成 "12,345,678"。可见是需要把相应的位置替换成 ","。

使用 `(?=\d{3}$)` 就可以做到:

```js
var result = "12345678".replace(/(?=\d{3}$)/g, ',')
console.log(result);
// => "12345,678"
```

改进

```js
var result = "12345678".replace(/(?=(\d{3})+$)/g, ',')
console.log(result);
// => "12,345,678"
```

写完正则后，要多验证几个案例，此时我们会发现问题:

```js
var result = "123456789".replace(/(?=(\d{3})+$)/g, ',')
console.log(result);
// => ",123,456,789"
```

怎么解决呢?我们要求匹配的到这个位置不能是开头。我们知道匹配开头可以使用` ^`，但要求这个位置不是开头怎么办? `(?!^)`

```js
var regex = /(?!^)(?=(\d{3})+$)/g;
var result = "12345678".replace(regex, ',')
console.log(result);
// => "12,345,678"
result = "123456789".replace(regex, ',');
console.log(result);
// => "123,456,789"
```



1. 验证密码问题：密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。

初始不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出:

```js
var regex = /^[0-9A-Za-z]{6,12}$/;
```

2. 判断是否包含有某一种字符

假设，要求的必须包含数字，怎么办?此时我们可以使用 `(?=.*[0-9])` 来做。

```js
var regex = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;
```

3. 最后，同时包含具体两种字符

比如同时包含数字和小写字母，可以用 `(?=.[0-9])(?=.[a-z])` 来做

```js
var regex = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/;
```

**像  `(?=p)和(?!p)` 这些匹配位置要写在前面，可以匹配整个字符串。**

对于这个正则，我们只需要弄明白 `(?=.*[0-9])^` 即可。分开来看就是 `(?=.*[0-9])` 和` ^`。表示开头前面还有个位置(当然也是开头，即同一个位置，所以写在前面没什么影响，还可以匹配整个字符串)。

翻译成大白话，就是接下来的字符，必须包含个数字。



### 第三章 正则表达式括号的作用

#### 3.1 分组和分支结构

- `/(ab)+/`
- `(p1|p2)`

##### 3.1.1 分组

我们知道 /a+/ 匹配连续出现的 "a"，而要匹配连续出现的 "ab" 时，需要使用 /(ab)+/。

##### 3.1.2 分支结构

`(p1|p2)`，即p1或p2

```js
var regex = /^I love (JavaScript|Regular Expression)$/;
console.log( regex.test("I love JavaScript") );
console.log( regex.test("I love Regular Expression") );
// => true
// => true 
```

#### 3.2 分组引用

括号的作用就是对匹配的数据进行分组，我们也可以进行数据提取，以及更强大的替换操作。

##### 3.2.1 提取数据

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
console.log( string.match(regex) );
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]

let reg = /(\d{4})-(\d{2})-(\d{2})/g;
console.log( string.match(regex) );
//["2017-06-12"]
```

> match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组(括号里)匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match 返回的数组格式是不一样的。 

另外也可以使用正则实例对象的 `exec` 方法

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
console.log( regex.exec(string) );
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

同时，也可以使用构造函数的全局属性 `$1` 至 `$9` 来获取:

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
regex.test(string); // 正则操作即可，例如 
//regex.exec(string); 
//string.match(regex);

console.log(RegExp.$1); // "2017"
console.log(RegExp.$2); // "06"
console.log(RegExp.$3); // "12"
```

##### 3.2.2 替换

yyyy-mm-dd 格式，替换成 mm/dd/yyyy

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result);
// => "06/12/2017"
```

等价于如下的形式：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function () {
    return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result);
// => "06/12/2017"
```

也等价于:

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function (match, year, month, day) {
    return month + "/" + day + "/" + year;
});
console.log(result);
// => "06/12/2017"
```

#### 3.3 反向引用

```js
//这里的\1表示之前第一个分组的值
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
console.log( regex.test(string1) ); // true
console.log( regex.test(string2) ); // true
console.log( regex.test(string3) ); // true
console.log( regex.test(string4) ); // false
```

![](./images/1548745192745.jpg)

注意里面的 `\1`，表示的引用之前的那个分组` (-|\/|\.)`。不管它匹配到什么(比如 `-`)，`\1` 都匹配那个同样的具体某个字符。 

我们知道了 `\1` 的含义后，那么 `\2` 和 `\3` 的概念也就理解了，即分别指代第二个和第三个分组。 

看到这里，此时，恐怕你会有几个问题。

##### 3.3.1 括号嵌套怎么办？

```js
var regex = /^((\d)(\d(\d)))\1\2\3\4$/;
var string = "1231231233";
console.log( regex.test(string) ); // true
console.log( RegExp.$1 ); // 123
console.log( RegExp.$2 ); // 1
console.log( RegExp.$3 ); // 23
console.log( RegExp.$4 ); // 3
/*所以
\1是分组1，找到第一个开括号，123
\2是分组2，找到第二个开括号，1
\3是分组3，找到第三个开括号，23
\4是分组4，找到第四个开括号，3
*/
```

![](./images/1548745292884.jpg)

##### 3.3.2 \10表示什么呢？

另外一个疑问可能是，即 `\10` 是表示第 10 个分组，还是 `\1` 和 `0` 呢? 答案是前者，虽然一个正则里出现 `\10` 比较罕见。

##### 3.3.3 引用不存在的分组会怎样?

因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配
反向引用的字符本身。例如` \2`，就匹配 `"\2"`。注意 `"\2"` 表示对 `"2"` 进行了转义。

##### 3.3.4 分组后面有量词会怎样?

分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。

```js
var regex = /(\d)+/;
var string = "12345";
console.log( string.match(regex) );
// => ["12345", "5", index: 0, input: "12345"]
```

从上面看出，分组 `(\d) `捕获的数据是` "5"`。

同理对于反向引用，也是这样的。测试如下:

```js
var regex = /(\d)+ \1/;
console.log( regex.test("12345 1") );
// => false
console.log( regex.test("12345 5") );js
// => true
```

#### 3.4 非捕获括号

如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。

此时可以使用非捕获括号`(?:p)` 和 `(?:p1|p2|p3)`。

```js
var regex = /(?:ab)+/g;
var string = "ababa abbb ababab";
console.log( string.match(regex) );
// => ["abab", "ab", "ababab"]
```

```js
var regex = /^I love (?:JavaScript|Regular Expression)$/;
console.log( regex.test("I love JavaScript") );
console.log( regex.test("I love Regular Expression") );
// => true
// => true
```

#### 3.5 例子

##### 3.5.1 字符串trim方法模拟

去掉开头和结尾的空白。

第一种

```js
function trim(str) {
    return str.replace(/^\s+|\s+$/g, '')
}
console.log( trim("  foobar   ") );
// => "foobar"
```

第二种

```js
function trim (str) {
    return str.replace(/^\s*(.*?)\s*$/g, "$1");
}
console.log( trim("  foobar   ") );
// => "foobar"
```

这里使用了惰性匹配`*?`，不然也会匹配最后一个空格之前的所有空格的。

##### 3.5.2 将每个单词的首字母转为大写

```js
function titleize (str) {
    								//单词开头或者空白+单词
    return str.toLowerCase().replace(/(?:^|\s)\w/g, function (c) {
        return c.toUpperCase();
    });
}
console.log( titleize('my name is epeli') );
// => "My Name Is Epeli"
```

##### 3.5.3 驼峰化

```js
function camelize (str) {
    return str.replace(/[-_\s]+(.)?/g, function (match, c) {
        return c ? c.toUpperCase() : '';
    });
}
console.log( camelize('-moz-transform') );
// => "MozTransform"
```

正则后面 的 ? 的目的，是为了应对 str 尾部的字符可能不是单词字符，比如 str 是 '-moz-transform ' 

### 第四章 正则表达式回溯法原理

学习正则表达式，是需要懂点儿匹配原理的。而研究匹配原理时，有两个字出现的频率比较高:“回溯”。

#### 4.1 没有回溯的匹配

假设我们的正则是 /ab{1,3}c/，而当目标字符串是 "abbbc" 时，就没有所谓的“回溯”。其匹配过程是:

![](./images/1548837100179.jpg)

#### 4.2 有回溯的匹配

1. 例子1

RegExp： `/ab{1,3}c/`

目标字符串：`"abbc"`

中间就有回溯。

![](./images/1548837225488.jpg)

图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 "b"，准备尝试第三个时， 结果发现接下来的字符是 "c"。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态(即 第 6 步与第 4 步一样)，最后再用子表达式 c，去匹配字符 "c"。当然，此时整个表达式匹配成功了。 图中的第 6 步，就是“回溯”。 

2. 例子2

RegExp：`/ab{1,3}bbc/`

目标字符串：`"abbbc"`

匹配的过程是：

![](./images/1548837666229.jpg)

3. 例子3

RegExp：`/".*"/`

目标字符串：`"abc"de`

![](./images/1548837942566.jpg)

可以看出 `.*` 是非常影响效率的，为了减少一些不必要的回溯，可以把正则修改为 `/"[^"]*"/`。

#### 4.3 常见的回溯形式

正则表达式匹配字符串的这种方式，有个学名，叫回溯法。

> 回溯法也称试探法，它的基本思想是:从问题的某一种状态(初始状态)出发，搜索从这种状态出发
> 所能达到的所有“状态”，当一条路走到“尽头”的时候(不能再前进)，再后退一步或若干步，从
> 另一种可能“状态”出发，继续搜索，直到所有的“路径”(状态)都试探过。这种不断“前进”、
> 不断“回溯”寻找解的方法，就称作“回溯法”。------百度百科

本质上就是深度优先搜索算法。

##### 4.3.1 贪婪量词

之前的例子都是贪婪量词相关的。比如 b{1,3}，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝
试。首先会尝试 "bbb"，然后再看整个正则是否能匹配。不能匹配时，吐出一个 "b"，即在 "bb" 的基础
上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢?只能说明匹配失败了。

如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样?答案是，先下手为强!因为深度优先搜索。测试如下:

```js
var string = "12345";
var regex = /(\d{1,3})(\d{1,3})/;
console.log( string.match(regex) );
// => ["12345", "123", "45", index: 0, input: "12345"]
```

##### 4.3.2 惰性量词

惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配：

```js
var string = "12345";
var regex = /(\d{1,3}?)(\d{1,3})/;
console.log( string.match(regex) );
// => ["1234", "1", "234", index: 0, input: "12345"]
```

虽然惰性量词不贪，但也会有回溯的现象。比如正则是:

RegExp：`/^\d{1,3}?\d{1,3}$/`

目标字符串：`"12345"`

![](./images/1548840421991.jpg)

知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \d{1,3}? 匹配的字
符是 "12"，是两个数字，而不是一个。

##### 4.3.3 分支结构

我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 "candy"，得到的结果是 "can"，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。 

分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。 比如正则：

RegExp：`/^(can|candy)$/`

目标字符串：`"candy"`

![](./images/1548840730962.jpg)

